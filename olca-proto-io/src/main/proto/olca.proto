// Generated from olca-schema (https://github.com/GreenDelta/olca-schema).
// DO NOT EDIT!

syntax = "proto3";

package protolca;

option java_package = "org.openlca.proto.generated";
option java_outer_classname = "Proto";
option csharp_namespace = "ProtoLCA";
option go_package = ".;protolca";

import "entity_type.proto";

// An actor is a person or organisation.
message Actor {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  string address = 10;

  string city = 11;

  string country = 12;

  string email = 13;

  string telefax = 14;

  string telephone = 15;

  string website = 16;

  string zip_code = 17;

}

// A single allocation factor in a process.
message AllocationFactor {

  // The type of allocation.
  AllocationType allocation_type = 1;

  // The output product (or waste input) to which this allocation factor is
  // related. The must be an exchange with this product output (or waste input)
  // in this process.
  Ref product = 2;

  // The value of the allocation factor.
  double value = 3;

  // An optional formula from which the value of the allocation factor is
  // calculated.
  string formula = 4;

  // A product input, waste output, or elementary flow exchange which is
  // allocated by this factor. This is only valid for causal allocation where
  // allocation factors can be assigned to single exchanges.
  ExchangeRef exchange = 5;

}

// An enumeration type for allocation methods. This type is used to define the
// type of an [AllocationFactor], the default allocation method of a
// multi-functional [Process], or the allocation method in a
// [CalculationSetup].
enum AllocationType {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_ALLOCATION_TYPE = 0;

  PHYSICAL_ALLOCATION = 1;

  ECONOMIC_ALLOCATION = 2;

  CAUSAL_ALLOCATION = 3;

  USE_DEFAULT_ALLOCATION = 4;

  NO_ALLOCATION = 5;

}

// A setup for a product system calculation.
message CalculationSetup {

  // The type of calculation that should be performed.
  CalculationType calculation_type = 1;

  // The product system that should be calculated (required).
  Ref product_system = 2;

  // The LCIA method for the calculation (optional).
  Ref impact_method = 3;

  // Indicates whether life cycle costs should be also calculated (optional).
  bool with_costs = 4;

  // Indicates whether a regionalized result should be calculated or not. If
  // this is set to true, the intervention matrix is indexed by (elementary
  // flow, location) - pairs instead of just elementary flows. The LCI result
  // then contains results for these pairs which can be then used in
  // regionalized impact assessments.
  bool with_regionalization = 5;

  // The normalisation and weighting set for the calculation (optional).
  Ref nw_set = 6;

  // The calculation type to be used in the calculation (optional).
  AllocationType allocation_method = 7;

  // A list of parameter redefinitions to be used in the calculation
  // (optional).
  repeated ParameterRedef parameter_redefs = 8;

  // (optional)
  double amount = 9;

  // (optional)
  Ref unit = 10;

  // (optional)
  Ref flow_property = 11;

}

// An enumeration of the different calculation methods supported by openLCA.
enum CalculationType {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_CALCULATION_TYPE = 0;

  // Calculates the total results for elementary flows, LCIA indicators, costs,
  // etc. of a product system.
  SIMPLE_CALCULATION = 1;

  // Includes the total result vectors of a simple calculation but calculates
  // also the direct contributions of each process (or better process product
  // in case of multi-output processes) to these total results.
  CONTRIBUTION_ANALYSIS = 2;

  // Extends the contribution analysis by providing also the upstream results
  // of each process (process product) in the product system. The upstream
  // result contains the direct contributions of the respective process but
  // also the result of the supply chain up to this process scaled to the
  // demand of the process in the product system.
  UPSTREAM_ANALYSIS = 3;

  // A regionalized calculation is a contribution analysis but with an LCIA
  // method that supports regionalized characterization factors (via region
  // specific parameters in formulas) and a product system with processes that
  // have geographic information assigned (point, line, or polygon shapes).
  REGIONALIZED_CALCULATION = 4;

  // A Monte Carlo simulation generates for each run, of a given number of a
  // given number of iterations, random values according to the uncertainty
  // distributions of process inputs/outputs, parameters, characterization
  // factors, etc. of a product system and then performs a simple calculation
  // for that specific run.
  MONTE_CARLO_SIMULATION = 5;

}

// A category is used for the categorisation of types like processes, flows,
// etc. The tricky thing is that the `Category` class inherits also from the
// [CategorizedEntity] type so that a category can have a category attribute
// which is then the parent category of this category (uff).
message Category {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The type of models that can be linked to the category.
  ModelType model_type = 10;

}

message Currency {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  string code = 10;

  double conversion_factor = 11;

  Ref reference_currency = 12;

}

// An indicator of a data quality system ([DQSystem]).
message DQIndicator {

  string name = 1;

  int32 position = 2;

  repeated DQScore scores = 3;

}

// An score value of an indicator ([DQIndicator]) in a data quality system
// ([DQSystem]).
message DQScore {

  int32 position = 1;

  string label = 2;

  string description = 3;

  double uncertainty = 4;

}

// A data quality system (DQS) in openLCA describes a pedigree matrix of $m$
// data quality indicators (DQIs) and $n$ data quality scores (DQ scores). Such
// a system can then be used to assess the data quality of processes and
// exchanges by tagging them with an instance of the system $D$ where $D$ is a
// $m * n$ matrix with an entry $d_{ij}$ containing the value of the data
// quality score $j$ for indicator $i$. As each indicator in $D$ can only have
// a single score value, $D$ can be stored in a vector $d$ where $d_i$ contains
// the data quality score for indicator $i$. The possible values of the data
// quality scores are defined as a linear order $1 \dots n$. In openLCA, the
// data quality entry $d$ of a process or exchange is stored as a string like
// `(3;2;4;n.a.;2)` which means the data quality score for the first indicator
// is `3`, for the second `2` etc. A specific value is `n.a.` which stands for
// _not applicable_. In calculations, these data quality entries can be
// aggregated in different ways. For example, the data quality entry of a flow
// $f$ with a contribution of `0.5 kg` and a data quality entry of
// `(3;2;4;n.a.;2)` in a process $p$ and a contribution of `1.5 kg` and a data
// quality entry of `(2;3;1;n.a.;5)` in a process $q$ could be aggregated to
// `(2;3;2;n.a.;4)` by applying an weighted average and rounding. Finally,
// custom labels like `A, B, C, ...` or `Very good, Good, Fair, ...` for the DQ
// scores can be assigned by the user. These labels are then displayed instead
// of `1, 2, 3 ...` in the user interface or result exports. However,
// internally the numeric values are used in the data model and calculations.
message DQSystem {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  bool has_uncertainties = 10;

  Ref source = 11;

  repeated DQIndicator indicators = 12;

}

// An Exchange is an input or output of a [Flow] in a [Process]. The amount of
// an exchange is given in a specific unit of a quantity ([FlowProperty]) of
// the flow. The allowed units and flow properties that can be used for a flow
// in an exchange are defined by the flow property information in that flow
// (see also the [FlowPropertyFactor] type).
message Exchange {

  // Indicates whether this exchange is an avoided product.
  bool avoided_product = 1;

  // A formula for calculating the costs of this exchange.
  string cost_formula = 2;

  // The costs of this exchange.
  double cost_value = 3;

  // The currency in which the costs of this exchange are given.
  Ref currency = 4;

  // The process internal ID of the exchange. This is used to identify
  // exchanges unambiguously within a process (e.g. when linking exchanges in a
  // product system where multiple exchanges with the same flow are allowed).
  // The value should be >= 1.
  int32 internal_id = 5;

  // The reference to the flow of the exchange.
  Ref flow = 6;

  // The quantity in which the amount is given.
  Ref flow_property = 7;

  bool input = 8;

  // Indicates whether the exchange is the quantitative reference of the
  // process.
  bool quantitative_reference = 9;

  double base_uncertainty = 10;

  // A default provider is a [Process] that is linked as the provider of a
  // product input or the waste treatment provider of a waste output. It is
  // just an optional default setting which can be also ignored when building
  // product systems in openLCA. The user is always free to link processes in
  // product systems ignoring these defaults (but the flows and flow directions
  // have to match of course).
  Ref default_provider = 11;

  double amount = 12;

  string amount_formula = 13;

  Ref unit = 14;

  // A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
  // quality values that need to match the data quality scheme for flow inputs
  // and outputs that is assigned to the [Process]. In such a scheme the data
  // quality indicators have fixed positions and the respective values in the
  // `dqEntry` vector map to these positions.
  string dq_entry = 15;

  Uncertainty uncertainty = 16;

  // A general comment about the input or output.
  string description = 17;

}

// An instance of this class describes a reference to an exchange in a process.
// When we reference such an exchange we only need the information to indentify
// that exchange unambiguously in a process.
message ExchangeRef {

  // The internal ID of the exchange.
  int32 internal_id = 1;

}

// Everything that can be an input or output of a process (e.g. a substance, a
// product, a waste, a service etc.)
message Flow {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The type of the flow. Note that this type is more a descriptor of how the
  // flow is handled in calculations.
  FlowType flow_type = 10;

  // A CAS number of the flow.
  string cas = 11;

  // A chemical formula of the flow.
  string formula = 12;

  // The flow properties (quantities) in which amounts of the flow can be
  // expressed together with conversion factors between these flow flow
  // properties.
  repeated FlowPropertyFactor flow_properties = 13;

  // The location of the flow. Normally the location of a flow is defined by
  // the process location where the flow is an input or output. However, some
  // data formats define a location as a property of a flow.
  Ref location = 14;

  // A list of synonyms but packed into a single field. Best is to use
  // semicolons as separator as commas are sometimes used in names of
  // chemicals.
  string synonyms = 15;

  // Indicates whether this flow describes an infrastructure product. This
  // field is part of the openLCA schema because of backward compatibility with
  // EcoSpold 1. It does not really have a meaning in openLCA and should not be
  // used anymore.
  bool infrastructure_flow = 16;

}

// A crosswalk of flows from a source flow list to a target flow list.
message FlowMap {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The reference (id, name, description) of the source flow list.
  Ref source = 6;

  // The reference (id, name, description) of the target flow list.
  Ref target = 7;

  // A list of flow mappings from flows in a source flow list to flows in a
  // target flow list.
  repeated FlowMapEntry mappings = 8;

}

// A mapping from one flow to another.
message FlowMapEntry {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The flow, flow property, and unit of the source flow.
  FlowMapRef from = 6;

  // The flow, flow property, and unit of the target flow.
  FlowMapRef to = 7;

  // The factor to convert the original source flow to the target flow.
  double conversion_factor = 8;

}

// Describes a the source or target flow of a flow mapping in a `FlowMap`. Such
// a flow reference can also optionally specify the unit and flow property
// (quantity) for which the mapping is valid. If the unit and quantity are not
// given, the mapping is based on the reference unit of the reference flow
// property of the respective flow.
message FlowMapRef {

  // The reference to the flow data set.
  Ref flow = 1;

  // An optional reference to a flow property of the flow for which the mapping
  // is valid.
  Ref flow_property = 2;

  // An optional reference to a unit of the flow for which the mapping is valid
  Ref unit = 3;

  // In case of a product or waste flow a flow mapping can contain a provider
  // which is the process that produces the product or a waste treatment
  // process that consumes the waste flow. This is useful when we want to apply
  // mappings of product and waste flows on databases and link them in the
  // corresponding processes and product systems.
  Ref provider = 4;

}

// A flow property is a quantity that can be used to express amounts of a flow.
message FlowProperty {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The type of the flow property
  FlowPropertyType flow_property_type = 10;

  // The units of measure that can be used to express quantities of the flow
  // property.
  Ref unit_group = 11;

}

// A FlowPropertyFactor is a conversion factor between <a
// href="./FlowProperty.html">flow properties (quantities)</a> of a <a
// href="./Flow.html">flow</a>. As an example the amount of the flow 'water' in
// a process could be expressed in 'kg' mass or 'm3' volume. In this case the
// flow water would have two flow property factors: one for the flow property
// 'mass' and one for 'volume'. Each of these flow properties has a reference
// to a <a href="./UnitGroup.html">unit group</a> which again has a reference
// unit. In the example the flow property 'mass' could reference the unit group
// 'units of mass' with 'kg' as reference unit and volume could reference the
// unit group 'units of volume' with 'm3' as reference unit. The flow property
// factor is now the conversion factor between these two reference units where
// the factor of the reference flow property of the flow is 1. If the reference
// flow property of 'water' in the example would be 'mass' the respective flow
// property factor would be 1 and the factor for 'volume' would be 0.001 (as 1
// kg water is 0.001 m3). The amount of water in a process can now be also
// given in liter, tons, grams etc. For this, the unit conversion factor of the
// respective unit group can be used to convert into the reference unit (which
// then can be used to convert to the reference unit of another flow property).
// Another thing to note is that different flow properties can refer to the
// same unit group (e.g. MJ upper calorific value and MJ lower calorific
// value.)
message FlowPropertyFactor {

  // The flow property (quantity) of the factor.
  Ref flow_property = 1;

  // The value of the conversion factor.
  double conversion_factor = 2;

  // Indicates whether the flow property of the factor is the reference flow
  // property of the flow. The reference flow property must have a conversion
  // factor of 1.0 and there should be only one reference flow property.
  bool reference_flow_property = 3;

}

// An enumeration of flow property types.
enum FlowPropertyType {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_FLOW_PROPERTY_TYPE = 0;

  ECONOMIC_QUANTITY = 1;

  PHYSICAL_QUANTITY = 2;

}

// A result value for a flow; given in the reference unit of the flow.
message FlowResult {

  // The flow reference.
  Ref flow = 1;

  // Indicates whether the flow is an input or not.
  bool input = 2;

  // The value of the flow amount.
  double value = 3;

  // The (reference to the) location of this flow result in case of a
  // regionalized result.
  Ref location = 4;

}

// The basic flow types.
enum FlowType {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_FLOW_TYPE = 0;

  ELEMENTARY_FLOW = 1;

  PRODUCT_FLOW = 2;

  WASTE_FLOW = 3;

}

message ImpactCategory {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The name of the reference unit of the LCIA category (e.g. kg CO2-eq.).
  string reference_unit_name = 10;

  // A set of parameters which can be used in formulas of the characterisation
  // factors in this impact category.
  repeated Parameter parameters = 11;

  // The characterisation factors of the LCIA category.
  repeated ImpactFactor impact_factors = 12;

}

// A single characterisation factor of a LCIA category for a flow.
message ImpactFactor {

  // The [Flow] of the impact assessment factor.
  Ref flow = 1;

  // In case of a regionalized impact category, this field can contain the
  // location for which this factor is valid.
  Ref location = 2;

  // The quantity of the flow to which the LCIA factor is related (e.g. Mass).
  Ref flow_property = 3;

  // The flow unit to which the LCIA factor is related (e.g. kg).
  Ref unit = 4;

  // The value of the impact assessment factor.
  double value = 5;

  // A mathematical formula for calculating the value of the LCIA factor.
  string formula = 6;

  // The uncertainty distribution of the factors' value.
  Uncertainty uncertainty = 7;

}

// An impact assessment method.
message ImpactMethod {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The impact categories of the method.
  repeated Ref impact_categories = 10;

  // The normalization and weighting sets of the method.
  repeated NwSet nw_sets = 11;

}

// A result value for an impact assessment category.
message ImpactResult {

  // The reference to the impact assessment category.
  Ref impact_category = 1;

  // The value of the flow amount.
  double value = 2;

}

// A location like a country, state, city, etc.
message Location {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The code of the location (e.g. an ISO 2-letter country code).
  string code = 10;

  // The average latitude of the location.
  double latitude = 11;

  // The average longitude of the location.
  double longitude = 12;

  // A GeoJSON object.
  // When we map to the bytes type it means that we have no matching message
  // type and just put the raw bytes into the field. This is specifically true
  // for our geometry data of locations which cannot be translated to valid
  // GeoJSON using Protocol Buffers (as they do not support arrays of arrays).
  // To indicate that this is a different field than the field in the
  // olca-schema definition, we append the _bytes suffix to the field name
  bytes geometry_bytes = 13;

}

// An enumeration of the root entity types.
enum ModelType {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_MODEL_TYPE = 0;

  ACTOR = 1;

  CATEGORY = 2;

  CURRENCY = 3;

  DQ_SYSTEM = 4;

  FLOW = 5;

  FLOW_PROPERTY = 6;

  IMPACT_CATEGORY = 7;

  IMPACT_METHOD = 8;

  LOCATION = 9;

  NW_SET = 10;

  PARAMETER = 11;

  PROCESS = 12;

  PRODUCT_SYSTEM = 13;

  PROJECT = 14;

  SOCIAL_INDICATOR = 15;

  SOURCE = 16;

  UNIT = 17;

  UNIT_GROUP = 18;

}

// A normalization and weighting factor of a [NwSet] related to an impact
// category. Depending on the purpose of the [NwSet] (normalization, weighting,
// or both) the normalization and weighting factor can be present or not.
message NwFactor {

  Ref impact_category = 1;

  double normalisation_factor = 2;

  double weighting_factor = 3;

}

// A normalization and weighting set.
message NwSet {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // This is the optional unit of the (normalized and) weighted score when this
  // normalization and weighting set was applied on a LCIA result.
  string weighted_score_unit = 6;

  // The list of normalization and weighting factors of this set.
  repeated NwFactor factors = 7;

}

// In openLCA, parameters can be defined in different scopes: global, process,
// or LCIA method. The parameter name can be used in formulas and, thus, need
// to conform to a specific syntax. Within a scope the parameter name should be
// unique (otherwise the evaluation is not deterministic). There are two types
// of parameters in openLCA: input parameters and dependent parameters. An
// input parameter can have an optional uncertainty distribution but not a
// formula. A dependent parameter can (should) have a formula (where also other
// parameters can be used) but no uncertainty distribution.
message Parameter {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The scope where the parameter is valid.
  ParameterScope parameter_scope = 10;

  // Indicates whether the parameter is an input parameter (true) or a
  // dependent/calculated parameter (false). A parameter can have a formula if
  // it is not an input parameter.
  bool input_parameter = 11;

  // The parameter value.
  double value = 12;

  // A mathematical expression to calculate the parameter value.
  string formula = 13;

  // An uncertainty distribution of the parameter value. This is only valid for
  // input parameters.
  Uncertainty uncertainty = 14;

}

// A redefinition of a parameter in a product system.
message ParameterRedef {

  // The context of the paramater (a process or LCIA method). If no context is
  // provided it is assumed that this is a redefinition of a global parameter.
  Ref context = 1;

  // A description of this parameter redefinition.
  string description = 2;

  // The name of the redefined parameter. Note that parameter names are used in
  // formulas so they need to follow specific syntax rules. A redefinition
  // replaces a bound parameter in a specific context and thus has to exactly
  // match the respective name.
  string name = 3;

  // An uncertainty distribution for the redefined parameter value.
  Uncertainty uncertainty = 4;

  // The value of the redefined parameter.
  double value = 5;

}

// An instance of this class is just a set of parameter redefinitions attached
// to a product system. It can have a name and a description. One of the
// parameter sets can be defined as the baseline of the product system. In the
// calculation the baseline set is then taken by default.
message ParameterRedefSet {

  // The name of the parameter set.
  string name = 1;

  // A description of the parameter set.
  string description = 2;

  // Indicates if this set of parameter redefinitions is the baseline for a
  // product system.
  bool is_baseline = 3;

  // The parameter redefinitions of this redefinition set.
  repeated ParameterRedef parameters = 4;

}

// The possible scopes of parameters. Parameters can be defined globally, in
// processes, or impact categories. They can be redefined in calculation setups
// on the project and product system level, but the initial definition is
// always only global, in a process, or an LCIA category.
enum ParameterScope {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_PARAMETER_SCOPE = 0;

  // Indicates that the evaluation scope of a parameter is the process where it
  // is defined.
  PROCESS_SCOPE = 1;

  // Indicates that the evaluation scope of a parameter is the impact category
  // where it is defined.
  IMPACT_SCOPE = 2;

  // Indicates that the evaluation scope of a parameter is the global scope.
  GLOBAL_SCOPE = 3;

}

message Process {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  repeated AllocationFactor allocation_factors = 10;

  AllocationType default_allocation_method = 11;

  // The inputs and outputs of the process.
  repeated Exchange exchanges = 12;

  // This field holds the last internal ID that was used in an exchange (which
  // may have been deleted, so it can be larger than the largest internal ID of
  // the exchanges of the process.) The internal ID of an exchange is used to
  // identify exchanges within a process (for updates, data exchanges (see
  // process links), etc.). When you add an exchange to a process, you should
  // increment this field in the process and set the resulting value as the
  // internal ID of that exchange. The sequence of internal IDs should start
  // with `1`.
  int32 last_internal_id = 13;

  // The location of the process.
  Ref location = 14;

  repeated Parameter parameters = 15;

  ProcessDocumentation process_documentation = 16;

  ProcessType process_type = 17;

  // A reference to a data quality system ([DQSystem]) with which the overall
  // quality of the process can be assessed.
  Ref dq_system = 18;

  // A reference to a data quality system ([DQSystem]) with which the quality
  // of individual inputs and outputs ([Exchange]s) of the process can be
  // assessed.
  Ref exchange_dq_system = 19;

  // A reference to a data quality system ([DQSystem]) with which the quality
  // of individual social aspects of the process can be assessed.
  Ref social_dq_system = 20;

  // A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
  // quality values that need to match the overall data quality system of the
  // process (the system that is stored in the `dqSystem` property). In such a
  // system the data quality indicators have fixed positions and the respective
  // values in the `dqEntry` vector map to these positions.
  string dq_entry = 21;

  // Indicates whether this process describes an infrastructure process. This
  // field is part of the openLCA schema because of backward compatibility with
  // EcoSpold 1. It does not really have a meaning in openLCA and should not be
  // used anymore.
  bool infrastructure_process = 22;

  // A set of social aspects related to this process.
  repeated SocialAspect social_aspects = 23;

}

message ProcessDocumentation {

  string time_description = 1;

  string valid_until = 2;

  string valid_from = 3;

  string technology_description = 4;

  string data_collection_description = 5;

  string completeness_description = 6;

  string data_selection_description = 7;

  string review_details = 8;

  string data_treatment_description = 9;

  string inventory_method_description = 10;

  string modeling_constants_description = 11;

  Ref reviewer = 12;

  string sampling_description = 13;

  repeated Ref sources = 14;

  string restrictions_description = 15;

  bool copyright = 16;

  string creation_date = 17;

  Ref data_documentor = 18;

  Ref data_generator = 19;

  Ref data_set_owner = 20;

  string intended_application = 21;

  string project_description = 22;

  Ref publication = 23;

  string geography_description = 24;

}

// A process link is a connection between two processes in a product system.
message ProcessLink {

  // The descriptor of the process or product system that provides a product or
  // a waste treatment.
  Ref provider = 1;

  // The descriptor of the flow that is exchanged between the two processes.
  Ref flow = 2;

  // The descriptor of the process that is linked to the provider.
  Ref process = 3;

  // The exchange of the linked process (this is useful if the linked process
  // has multiple exchanges with the same flow that are linked to different
  // provides, e.g. in an electricity mix).
  ExchangeRef exchange = 4;

}

enum ProcessType {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_PROCESS_TYPE = 0;

  LCI_RESULT = 1;

  UNIT_PROCESS = 2;

}

// A product system describes the supply chain of a product (the functional
// unit) ...
message ProductSystem {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The descriptors of all processes and sub-systems that are contained in the
  // product system.
  repeated Ref processes = 10;

  // The descriptor of the process that provides the flow of the functional
  // unit of the product system.
  Ref reference_process = 11;

  // The exchange of the reference processes (typically the product output)
  // that provides the flow of the functional unit of the product system.
  ExchangeRef reference_exchange = 12;

  // The flow amount of the functional unit of the product system.
  double target_amount = 13;

  // The unit in which the flow amount of the functional unit is given.
  Ref target_unit = 14;

  // The flow property in which the flow amount of the functional unit is
  // given.
  Ref target_flow_property = 15;

  // The process links of the product system.
  repeated ProcessLink process_links = 16;

  // A list of possible sets of parameter redefinitions for this product
  // system.
  repeated ParameterRedefSet parameter_sets = 17;

}

message Project {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  Ref impact_method = 10;

  NwSet nw_set = 11;

}

// A Ref is a reference to a [RootEntity]. When serializing an entity (e.g. a
// [Process]) that references another standalone entity (e.g. a [Flow] in an
// [Exchange]) we do not want to write the complete referenced entity into the
// serialized JSON object but just a reference. However, the reference contains
// some meta-data like name, category path etc. that are useful to display.
message Ref {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The full path of the category of the referenced entity from top to bottom,
  // e.g. `"Elementary flows", "Emissions to air", "unspecified"`.
  repeated string category_path = 7;

  // If the entity that is described by this reference is part of a library,
  // this field contains the identifier of that library. The identifier is
  // typically just the combination of the library name and version.
  string library = 8;

  // This field is only valid for references of flows or impact categories and
  // contains the name (symbol) of the reference unit of that respective flow
  // or impact category.
  string ref_unit = 9;

  // This field is only valid for references of processes or flows and contains
  // the location name or code of that respective process or flow.
  string location = 10;

  // In case of a reference to a flow, this field can contain the type of flow
  // that is referenced.
  FlowType flow_type = 11;

  // In case of a reference to a process, this fiel can contain the type of
  // process that is referenced.
  ProcessType process_type = 12;

}

enum RiskLevel {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_RISK_LEVEL = 0;

  NO_OPPORTUNITY = 1;

  HIGH_OPPORTUNITY = 2;

  MEDIUM_OPPORTUNITY = 3;

  LOW_OPPORTUNITY = 4;

  NO_RISK = 5;

  VERY_LOW_RISK = 6;

  LOW_RISK = 7;

  MEDIUM_RISK = 8;

  HIGH_RISK = 9;

  VERY_HIGH_RISK = 10;

  NO_DATA = 11;

  NOT_APPLICABLE = 12;

}

message SimpleResult {

  repeated FlowResult flow_results = 1;

  repeated ImpactResult impact_results = 2;

}

// An instance of this class describes a social aspect related to a social
// indicator in a process.
message SocialAspect {

  // The value of the activity variable of the related indicator.
  double activity_value = 1;

  string comment = 2;

  // A data quality entry, e.g. `(3,1,2,4,1)`.
  string quality = 3;

  // The raw amount of the indicator's unit of measurement (not required to be
  // numeric currently)
  string raw_amount = 4;

  RiskLevel risk_level = 5;

  Ref social_indicator = 6;

  Ref source = 7;

}

message SocialIndicator {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // The name of the activity variable of the indicator.
  string activity_variable = 10;

  // The quantity of the activity variable.
  Ref activity_quantity = 11;

  // The unit of the activity variable.
  Ref activity_unit = 12;

  // The unit in which the indicator is measured.
  string unit_of_measurement = 13;

  // Documentation of the evaluation scheme of the indicator.
  string evaluation_scheme = 14;

}

// A source is a literature reference.
message Source {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // A URL that points to the source.
  string url = 10;

  // The full text reference of the source.
  string text_reference = 11;

  // The publication year of the source.
  int32 year = 12;

  // A direct link (relative or absolute URL) to the source file.
  string external_file = 13;

}

// Defines the parameter values of an uncertainty distribution. Depending on
// the uncertainty distribution type different parameters could be used.
message Uncertainty {

  // The uncertainty distribution type
  UncertaintyType distribution_type = 1;

  // The arithmetic mean (used for normal distributions).
  double mean = 2;

  // A mathematical formula for the arithmetic mean.
  string mean_formula = 3;

  // The geometric mean value (used for log-normal distributions).
  double geom_mean = 4;

  // A mathematical formula for the geometric mean.
  string geom_mean_formula = 5;

  // The minimum value (used for uniform and triangle distributions).
  double minimum = 6;

  // A mathematical formula for the minimum value.
  string minimum_formula = 7;

  // The arithmetic standard deviation (used for normal distributions).
  double sd = 8;

  // A mathematical formula for the arithmetic standard deviation.
  string sd_formula = 9;

  // The geometric standard deviation (used for log-normal distributions).
  double geom_sd = 10;

  // A mathematical formula for the geometric standard deviation.
  string geom_sd_formula = 11;

  // The most likely value (used for triangle distributions).
  double mode = 12;

  // A mathematical formula for the most likely value.
  string mode_formula = 13;

  // The maximum value (used for uniform and triangle distributions).
  double maximum = 14;

  // A mathematical formula for the maximum value.
  string maximum_formula = 15;

}

// Enumeration of uncertainty distribution types that can be used in exchanges,
// parameters, LCIA factors, etc.
enum UncertaintyType {

  // This default option was added automatically
  // and means that no values was set.
  UNDEFINED_UNCERTAINTY_TYPE = 0;

  LOG_NORMAL_DISTRIBUTION = 1;

  NORMAL_DISTRIBUTION = 2;

  TRIANGLE_DISTRIBUTION = 3;

  UNIFORM_DISTRIBUTION = 4;

}

// An unit of measure
message Unit {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The conversion factor to the reference unit of the unit group to which
  // this unit belongs.
  double conversion_factor = 6;

  // Indicates whether the unit is the reference unit of the unit group to
  // which this unit belongs. If it is the reference unit the conversion factor
  // must be 1.0. There should be always only one reference unit in a unit
  // group. The reference unit is used to convert amounts given in one unit to
  // amounts given in another unit of the respective unit group.
  bool reference_unit = 7;

  // A list of synonyms for the unit.
  repeated string synonyms = 8;

}

// A group of units that can be converted into each other.
message UnitGroup {

  // The reference ID (typically an UUID) of the entity.
  string id = 1 [json_name = "@id"];

  // The name of the entity.
  string name = 2;

  // The description of the entity.
  string description = 3;

  // A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
  // fields are optional and the fields may have leading zeros (so 01.00.00 is
  // the same as 1.0.0 or 1).
  string version = 4;

  // The timestamp when the entity was changed the last time.
  string last_change = 5;

  // The type name of the respective entity.
  protolca.commons.EntityType entity_type = 6 [json_name = "@type"];

  // The category of the entity.
  Ref category = 7;

  // A list of optional tags. A tag is just a string which should not contain
  // commas (and other special characters).
  repeated string tags = 8;

  // If this entity is part of a library, this field contains the identifier of
  // that library. The identifier is typically just the combination of the
  // library name and version.
  string library = 9;

  // Some LCA data formats do not have the concept of flow properties or
  // quantities. This field provides a default link to a flow property for
  // units that are contained in this group.
  Ref default_flow_property = 10;

  // The units of the unit group.
  repeated Unit units = 11;

}

