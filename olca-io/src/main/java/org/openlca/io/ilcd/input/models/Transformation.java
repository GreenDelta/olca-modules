package org.openlca.io.ilcd.input.models;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Queue;
import java.util.Set;

import org.openlca.core.model.Exchange;
import org.openlca.core.model.Flow;
import org.openlca.core.model.FlowProperty;
import org.openlca.core.model.FlowType;
import org.openlca.ilcd.commons.LangString;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

class Transformation {

	private final Logger log = LoggerFactory.getLogger(getClass());

	private final Graph source;
	private final Graph target;

	private final Queue<Node> next = new ArrayDeque<>();
	private final Set<Integer> visitedNodes = new HashSet<>();
	private final Set<Integer> visitedLinks = new HashSet<>();

	private Transformation(Graph source) {
		this.source = source;
		this.target = new Graph();
	}

	static Graph on(Graph source) {
		Transformation t = new Transformation(source);
		t.doIt();
		return t.target;
	}

	private void doIt() {
		target.root = forTarget(source.root);
		next.add(target.root);
		while (!next.isEmpty()) {
			visit(next.poll());
		}
		mapRefFlow();
	}

	/** Visits the given node which is already a node from the target graph. */
	private void visit(Node n) {
		if (visitedNodes.contains(n.id))
			return;
		visitedNodes.add(n.id);
		for (Link inLink : source.getInputLinks(n.id)) {
			if (visitedLinks.contains(inLink.id))
				continue;
			visitedLinks.add(inLink.id);
			linkProduct(n, inLink);
		}
		for (Link outLink : source.getOutputLinks(n.id)) {
			if (visitedLinks.contains(outLink.id))
				continue;
			visitedLinks.add(outLink.id);
			linkWaste(n, outLink);
		}
	}

	private void linkProduct(Node recipient, Link inLink) {
		Node provider = forTarget(inLink.provider);
		if (provider == null)
			return;
		Flow product = inLink.output.flow.copy();
		product.flowType = FlowType.PRODUCT_FLOW;
		Link link = link(provider, recipient, product, inLink);
		provider.process.quantitativeReference = link.output;
		next.add(provider);
	}

	private void linkWaste(Node provider, Link outLink) {
		Node recipient = forTarget(outLink.recipient);
		if (recipient == null)
			return;
		Flow waste = outLink.input.flow.copy();
		waste.flowType = FlowType.WASTE_FLOW;
		Link link = link(provider, recipient, waste, outLink);
		recipient.process.quantitativeReference = link.input;
		next.add(recipient);
	}

	private Link link(Node provider, Node recipient, Flow flow,
			Link sourceLink) {
		Exchange output = sourceLink.output.copy();
		Exchange input = sourceLink.input.copy();
		setFlow(flow, output);
		provider.process.exchanges.add(output);
		setFlow(flow, input);
		recipient.process.exchanges.add(input);
		Link link = new Link();
		link.input = input;
		link.output = output;
		link.provider = provider;
		link.recipient = recipient;
		target.putLink(link);
		return link;
	}

	private void setFlow(Flow flow, Exchange e) {
		e.flow = flow;
		e.unit = null;
		e.flowPropertyFactor = flow.getReferenceFactor();
		if (e.flowPropertyFactor == null) {
			log.warn("Could get a flow property factor for {}", flow);
			return;
		}
		FlowProperty prop = e.flowPropertyFactor.flowProperty;
		if (prop == null || prop.unitGroup == null) {
			log.warn("Could not determine unit group for {}", flow);
			return;
		}
		e.unit = prop.unitGroup.referenceUnit;
		if (e.unit == null) {
			log.warn("Could not determine unit group for {}", flow);
		}
	}

	/**
	 * Initialize a node for the target graph from the given node in the source
	 * graph. This creates a copy of the process with all product and waste
	 * flows removed. If the target graph already contains this node (identified
	 * via the model internal ID) this node will be returned.
	 */
	private Node forTarget(Node sourceNode) {
		if (sourceNode == null)
			return null;
		Node n = target.getNode(sourceNode.id);
		if (n != null)
			return n;
		n = sourceNode.copy();
		List<Exchange> elemFlows = new ArrayList<>();
		for (Exchange e : n.process.exchanges) {
			Flow f = e.flow;
			if (f == null || f.flowType != FlowType.ELEMENTARY_FLOW)
				continue;
			elemFlows.add(e);
		}
		n.process.exchanges.clear();
		n.process.exchanges.addAll(elemFlows);
		n.process.description = "This process was generated by converting an "
		+ "eILCD model to an openLCA product system. It\n"
		+ "should not be used outside of this system as "
		+ "its sole purpose is to translate the semantics\n"
		+ "of the eILCD model to the product system.\n\n"
		+ "The UUID of the original process is: "
		+ sourceNode.process.refId;

		if (sourceNode.group != null) {
			String prefix = LangString.getFirst(sourceNode.group.name, "en");
			if (prefix != null) {
				n.process.name = prefix + " :: " + n.process.name;
			}
		}

		target.putNode(n);
		return n;
	}

	private void mapRefFlow() {
		Exchange ref = source.root.process.quantitativeReference;
		if (ref == null || ref.flow == null) {
			log.warn("Ref. process of source graph has no reference flow.");
			return;
		}
		ref = ref.copy();
		Flow flow = ref.flow.copy();
		if (ref.isInput) {
			flow.flowType = FlowType.WASTE_FLOW;
		} else {
			flow.flowType = FlowType.PRODUCT_FLOW;
		}
		setFlow(flow, ref);
		target.root.process.exchanges.add(ref);
		target.root.process.quantitativeReference = ref;
	}
}
